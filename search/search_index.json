{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"`/]+|\\.(?!\\d)|&[lg]t;|(?!\\b)(?=[A-Z][a-z])","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Blog","text":""},{"location":"2024/10/01/integrating-jooq-with-spring-data/","title":"Integrating Jooq with Spring Data","text":"<p>In this post, we will explore the jooq-utils library, which provides seamless integration between Spring Data and Jooq. With jooq-utils, you can retrieve data using Jooq and get a <code>org.springframework.data.domain.Page</code> object as a result, and easily use <code>org.springframework.data.domain.Pageable</code> as input for repository methods.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooq-with-spring-data/#overview","title":"Overview","text":"<p>The <code>jooq-utils</code> library simplifies the pagination of Jooq results by enabling you to:</p> <ul> <li>Use Spring Data\u2019s <code>Pageable</code>   in your Jooq queries.</li> <li>Return paginated results in the form of <code>Page&lt;T&gt;</code>.</li> </ul> <p>This is especially useful in Spring-based applications that use Jooq for database interaction, where you need to integrate the pagination functionality of Spring Data.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooq-with-spring-data/#sample-code","title":"Sample Code","text":"<p>Let\u2019s walk through a sample use case to show how this library can be applied in your projects.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooq-with-spring-data/#1-create-the-repository","title":"1. Create the Repository","text":"<pre><code>import org.jooq.Condition\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.stereotype.Component\nimport org.dema.Tables.USERS\nimport org.dema.jooq.AbstractRepository\nimport org.dema.jooq.JooqUtils\n\n@Component\nclass UsersRepository : AbstractRepository&lt;Users, UsersRecord&gt;(table = USERS) {\n\n  fun getPageBy(pageable: Pageable, condition: Condition): Page&lt;UsersRecord&gt; {\n    val query = baseQuery({ condition })\n    return JooqUtils.paginate(dsl, query, pageable, USERS)\n  }\n\n  private fun baseQuery(vararg where: (Users) -&gt; Condition): SelectConditionStep&lt;UsersRecord&gt; {\n    return dsl.selectFrom(USERS)\n      .where(foldConditions(where))\n  }\n}\n</code></pre> <p>In the above code:</p> <p>We define a <code>UsersRepository</code> class that extends <code>AbstractRepository</code>. The <code>getPageBy()</code> method allows pagination of the user records based on the provided Condition and Pageable parameters. The actual pagination logic is handled by <code>JooqUtils.paginate()</code>.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooq-with-spring-data/#2-use-the-repository-in-a-service","title":"2. Use the Repository in a Service","text":"<pre><code>import org.jooq.Condition\nimport org.jooq.impl.DSL.noCondition\nimport org.springframework.data.domain.Page\nimport org.springframework.data.domain.Pageable\nimport org.springframework.stereotype.Service\nimport org.springframework.core.convert.ConversionService\nimport org.springframework.transaction.annotation.Transactional\n\n@Service\n@Transactional(readOnly = true)\nclass UsersService(\n  @Qualifier(\"mvcConversionService\") private val cs: ConversionService,\n  private val usersRepository: UsersRepository,\n) {\n\n  fun search(filter: UsersFilter, pageable: Pageable): UsersPage {\n    val filterCondition: Condition = filter?.let(cs::convert) ?: noCondition()\n    val userRecordsPage: Page&lt;UsersRecord&gt; = usersRepository.getPageBy(pageable, filterCondition)\n    return cs.convert(userRecordsPage)!!\n  }\n}\n</code></pre> <p>In the UsersService class:</p> <ul> <li>We define a <code>search()</code> method that receives a <code>UsersFilter</code> and a <code>Pageable</code>.</li> <li>The service converts the <code>filter</code> into a <code>Condition</code>, which is passed to the repository method <code>getPageBy()</code>.</li> <li>The paginated result is returned as a <code>UsersPage</code> after conversion.</li> </ul>","tags":["Kotlin","Jooq"]},{"location":"2024/10/01/integrating-jooq-with-spring-data/#3-conclusion","title":"3. Conclusion","text":"<p>You now have a working example of integrating Spring Data\u2019s pagination functionality into Jooq using jooq-utils. The provided repository and service examples demonstrate how to handle pagination in your Jooq queries with minimal code changes.</p>","tags":["Kotlin","Jooq"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/","title":"How to generate Interactive Database Documentation with SchemaSpy and Gradle","text":"<p>Gradle plugin that lets you generate database documentation using Schemaspy and Testcontainers</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#overview","title":"Overview","text":"<p>The schemaspy-gradle-plugin allows you to generate database documentation via DDL. Let`s consider an example. In the example I'll use postgres sakila schema.</p> <p>The plugin uses the following tools:</p> <ul> <li>SchemaSpy is a tool that generates interactive database documentation by analyzing your database schema. It's   especially useful for visualizing relationships between tables and understanding the overall structure of the   database.</li> <li>Gradle is a versatile build tool that automates the process of building, testing, and deploying software. Here, we use   it to integrate SchemaSpy easily into our build workflow.</li> <li>Testcontainers is a Java library that provides throwaway instances of databases (among other things) for integration   testing. In this context, it allows you to run a real instance of your database for generating documentation.</li> </ul> <p>These tools together allow you to automate the creation of up-to-date database documentation within your CI/CD pipeline, ensuring that developers and analysts always have the latest version available.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#how-to-use","title":"How to use","text":"<ol> <li>Add dependency:    <pre><code>plugins {\n id(\"io.github.denis-markushin.schemaspy-plugin\")\n}\n</code></pre></li> <li>Configure the plugin using an extension:    <pre><code>schemaspyConfig {\n  dbName = \"sakila\"\n  liquibaseChangelog = file(\"${project.projectDir}/src/main/resources/liquibase/changelog.yml\")\n  outputDir = project.layout.buildDirectory.dir(\"schemaspy/sakila\")\n}\n</code></pre></li> <li>Run <code>gradle generateSchemaspyDocs</code>.</li> <li> <p>Get output in gradle <code>build/schemaspy/db/output</code> folder.    </p> <p>Note</p> <p>Open <code>build/schemaspy/sakila/output/index.html</code> locally</p> </li> </ol>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#plugin-configuration-breakdown","title":"Plugin Configuration Breakdown","text":"<p>Let\u2019s break down the configuration steps in more detail to clarify the purpose of each setting:</p> <ol> <li><code>dbName</code>:    This property specifies the name of the database for which you want to generate the documentation. In our example,    it's set to \"sakila\" (a sample database for practice).</li> <li><code>liquibaseChangelog</code>:    This refers to the path of the Liquibase changelog file. Liquibase is a tool for managing database schema changes. By    specifying the changelog file here, the plugin can track and apply any updates to your database schema before    generating the documentation.</li> <li>postgresDockerImage:    The plugin uses Docker to run a PostgreSQL instance for generating the database documentation. This property allows    you to define which version of the PostgreSQL image to use. By default, it\u2019s set to \"postgres:13.5-alpine\", but you    can customize it if needed.</li> <li><code>schemaspyDockerImage</code>:    This defines the Docker image for SchemaSpy itself, which will be used to generate the interactive documentation. The    default value is \"schemaspy/schemaspy:6.1.0\", ensuring you're using a specific version of SchemaSpy.</li> <li><code>excludeTables</code>:    This property specifies tables that should be excluded from the documentation generation. By default, it excludes    Liquibase\u2019s internal tables like \"databasechangeloglock\" and \"databasechangelog\", as they are not relevant for schema    documentation purposes.</li> <li><code>unzipOutput</code>:    A boolean property that determines whether the output should be unzipped or not after the documentation is generated.    The default value is true, which means the documentation files will be unzipped for easier access.</li> <li><code>outputDir</code>:    This property defines the directory where the generated SchemaSpy output will be saved. You can specify any directory    of your choice, but in this case, it\u2019s configured to the build/schemaspy/sakila folder.</li> </ol> <p>These settings provide a lot of flexibility, allowing you to customize the plugin\u2019s behavior according to your project\u2019s requirements.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/10/10/how-to-generate-interactive-database-documentation-with-schemaspy-and-gradle/#conclusion","title":"Conclusion","text":"<p>Using the SchemaSpy Gradle plugin, you can effortlessly generate comprehensive database documentation. This documentation is not only beneficial for analytics but also serves various other purposes:</p> <ul> <li>For Developers: It helps developers understand the database structure, relationships, and dependencies, making it   easier to work with the data layer.</li> <li>For Testers: Testers can refer to the documentation to create effective test cases based on the actual database   schema and its constraints.</li> <li>For Compliance: Regulatory compliance often requires detailed documentation of data structures. This plugin   facilitates adherence to such requirements by providing clear and updated documentation.</li> </ul> <p>Additionally, you can integrate this process into your CI/CD pipeline to ensure that documentation is automatically generated and deployed to platforms like GitLab or GitHub, keeping your team aligned with the latest schema changes.</p> <p>The full example can be found on GitHub.</p>","tags":["Gradle","SchemaSpy","Database","Testcontainers"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/","title":"How to Use Virtual Threads in DGS","text":"<p>In this post, I\u2019ll explain how to use virtual threads with Netflix DGS in a GraphQL application. While exploring this feature, I encountered several undocumented challenges and found solutions that I\u2019m excited to share.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#overview","title":"Overview","text":"<p>The DataLoader pattern is essential for solving the N + 1 problem in GraphQL. The DGS Framework provides a convenient <code>@DgsDataLoader</code> annotation for implementing DataLoaders.</p> <p>To handle batched loading, I implemented the  <code>org.dataloader.MappedBatchLoader</code> interface. <code>MappedBatchLoader</code> is ideal when not all keys are expected to have values, as it creates a <code>Map</code> of key/values for a <code>Set</code> of keys rather than a <code>List</code> for a <code>List</code>.</p> <p>Additionally, DGS introduced virtual threads to improve concurrency. Below, I\u2019ll explain the steps I followed, the challenges I faced, and how I resolved them.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#sample-code","title":"Sample Code","text":"","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#implementing-a-dataloader","title":"Implementing a DataLoader","text":"<p>The <code>@DgsDataLoader</code> annotation simplifies creating DataLoaders. Here's my implementation:</p> <pre><code>@DgsDataLoader(caching = true)\nclass UsersDataLoader(\n  private val usersService: UsersService,\n  private val dgsAsyncTaskExecutor: Executor,\n) : MappedBatchLoader&lt;String, User?&gt; {\n\n  override fun load(ids: Set&lt;String&gt;): CompletionStage&lt;Map&lt;String, User?&gt;&gt; {\n    return CompletableFuture.supplyAsync({\n      usersService.getAllByUserIds(ids)\n        .associateBy { it.id }\n        .let { resultMap -&gt; keys.associateWith { resultMap[it] } }\n    }, dgsAsyncTaskExecutor)\n  }\n}\n</code></pre> <p>This implementation ensures efficient batching and mapping using <code>MappedBatchLoader</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#virtual-threads-in-dgs","title":"Virtual Threads in DGS","text":"","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#enabling-virtual-threads","title":"Enabling Virtual Threads","text":"<p>DGS Framework supports using virtual threads through a simple property:</p> <pre><code>dgs.graphql.virtualthreads.enabled=true\n</code></pre> <p>When enabled, each user-defined data fetcher executes in a new virtual thread, as confirmed by logs like:</p> <pre><code>2024-12-11 22:51:29.494 +0300 [,,] [dgs-virtual-thread-2] INFO [Logger] : #getById(...) in 389.88ms\n</code></pre>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#issue-with-spring-security","title":"Issue with Spring Security","text":"<p>However, when integrating Spring Security, if you use <code>@PreAuthorize</code>\\<code>@Secured</code>\\etc. for access control, you might encounter issues with context propagation. I encountered the following error:</p> <pre><code>An Authentication object was not found in the SecurityContext\n</code></pre> <p>This occurs because virtual threads do not automatically propagate the <code>SecurityContext</code>. For details, see the Spring Security documentation.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#fixing-security-context-propagation","title":"Fixing Security Context Propagation","text":"<p>The <code>DgsAutoConfiguration</code> class declares a bean for an <code>AsyncTaskExecutor</code> when the property <code>dgs.graphql.virtualthreads.enabled</code> is set to <code>true</code>:</p> <pre><code>@Bean\n@Qualifier(\"dgsAsyncTaskExecutor\")\n@ConditionalOnJava21\n@ConditionalOnMissingBean(name = [\"dgsAsyncTaskExecutor\"])\n@ConditionalOnProperty(name = [\"dgs.graphql.virtualthreads.enabled\"], havingValue = \"true\", matchIfMissing = false)\nopen fun virtualThreadsTaskExecutor(contextRegistry: ContextRegistry): AsyncTaskExecutor {\n  LOG.info(\"Enabling virtual threads for DGS\")\n  val contextSnapshotFactory = ContextSnapshotFactory.builder().contextRegistry(contextRegistry).build()\n  return VirtualThreadTaskExecutor(contextSnapshotFactory)\n}\n</code></pre> <p>However, this default <code>AsyncTaskExecutor</code> does not propagate the <code>SecurityContext</code>. To ensure compatibility with Spring Security, I wrapped it in a <code>DelegatingSecurityContextAsyncTaskExecutor</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#custom-configuration","title":"Custom Configuration","text":"<p>Here\u2019s the updated configuration:</p> <pre><code>@Configuration(proxyBeanMethods = false)\nclass AsyncExecutorConfig {\n\n  @Bean\n  fun dgsAsyncTaskExecutor(contextRegistry: ContextRegistry): AsyncTaskExecutor {\n    log.info(\"Enabling virtual threads for DGS\")\n    val contextSnapshotFactory = ContextSnapshotFactory.builder().contextRegistry(contextRegistry).build()\n    return DelegatingSecurityContextAsyncTaskExecutor(VirtualThreadTaskExecutor(contextSnapshotFactory))\n  }\n}\n</code></pre> <p>This ensures that the security context is properly propagated while using virtual threads.</p> <p>Note</p> <p>If you enable <code>dgs.graphql.virtualthreads.enabled=true</code>, you must disable this property to avoid conflicts with the <code>DgsAutoConfiguration</code>-provided bean that does not propagate the <code>SecurityContext</code>.</p>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#results","title":"Results","text":"<p>After applying these changes, my Data Fetchers run seamlessly on virtual threads while maintaining proper security context propagation. Logs show improved execution:</p> <pre><code>2024-12-11 22:51:30.496 +0300 [,,] [dgs-virtual-thread-4] INFO [Logger] : #getAllByIds(['1', '2']): [...] in 140.02ms\n</code></pre>","tags":["Kotlin","DGS"]},{"location":"2024/12/11/how-to-use-virtual-threads-in-dgs/#conclusion","title":"Conclusion","text":"<p>Using virtual threads in DGS can significantly enhance concurrency. However, for projects with Spring Security, additional configuration is required to propagate the <code>SecurityContext</code>. The steps outlined above should help you integrate this effectively and make the most of virtual threads in your GraphQL applications.</p>","tags":["Kotlin","DGS"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/","title":"Integration of Feign Clients and OpenAPI Generator: Enabling client_credentials","text":"<p>In this post, we will explore how to integrate the OpenAPI Generator Gradle Plugin with Spring Feign clients to obtain an OAuth 2.0 token using the <code>client_credentials</code> flow.</p>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#overview","title":"Overview","text":"<p>We will walk through:</p> <ul> <li>Declaring the OAuth 2.0 security scheme (client_credentials) in the OpenAPI specification</li> <li>Generating Feign clients using the OpenAPI Generator</li> <li>Adding Spring Boot OAuth 2.0 client configuration for Keycloak in <code>application.yml</code></li> </ul>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#openapi-specification-and-security-scheme","title":"OpenAPI Specification and Security Scheme","text":"<p>To enable OAuth 2.0 with a <code>client_credentials</code> flow, you need to define your security scheme in the OpenAPI specification. Below is a minimal example of how you can declare the scheme (based on this reference):</p> <pre><code>openapi: 3.0.3\ninfo:\n  title: My API\n  version: 1.0.0\n\npaths:\n  /example:\n    get:\n      security:\n        - OAuth2ClientCredentials: [ ]\n      responses:\n        '200':\n          description: Success\n\ncomponents:\n  securitySchemes:\n    OAuth2ClientCredentials:\n      type: oauth2\n      flows:\n        clientCredentials:\n          tokenUrl: https://my-keycloak-domain/auth/realms/myrealm/protocol/openid-connect/token\n          scopes:\n            read: Grants read access\n</code></pre> <p>When you generate code with the OpenAPI Generator, it will recognize the security scheme and allow for the configuration of OAuth 2.0 in your client.</p> <p>Note</p> <p>The property name for the Keycloak provider settings includes the suffix<code>Application</code>. For example, if your scheme is called <code>OAuth2ClientCredentials</code>, you might see something like <code>spring.security.oauth2.client.registration.oAuth2ClientCredentialsApplication</code> in your <code>application.yml</code>.</p> <p>Below is an example of such a generated configuration class:</p> <pre><code>import org.springframework.context.annotation.Bean;\nimport org.springframework.boot.autoconfigure.condition.ConditionalOnProperty;\nimport org.springframework.security.authentication.AnonymousAuthenticationToken;\nimport org.springframework.security.oauth2.client.AuthorizedClientServiceOAuth2AuthorizedClientManager;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizeRequest;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClient;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClientManager;\nimport org.springframework.security.oauth2.client.OAuth2AuthorizedClientService;\nimport org.springframework.security.oauth2.client.registration.ClientRegistrationRepository;\nimport org.springframework.security.oauth2.core.OAuth2AuthenticationException;\nimport org.springframework.security.oauth2.core.OAuth2AccessToken;\nimport org.springframework.security.core.authority.AuthorityUtils;\nimport org.springframework.http.HttpHeaders;\n\nimport feign.RequestInterceptor;\nimport feign.RequestTemplate;\n\nimport org.springframework.context.annotation.Configuration;\n\n\npublic class ClientConfiguration {\n\n  private static final String CLIENT_PRINCIPAL_APPLICATION = \"oauth2FeignClient\";\n\n  @Bean\n  @ConditionalOnProperty(\n    prefix = \"spring.security.oauth2.client.registration.oAuth2ClientCredentialsApplication\",\n    name = \"enabled\",\n    havingValue = \"true\"\n  )\n  public OAuth2RequestInterceptor applicationOAuth2RequestInterceptor(\n    final OAuth2AuthorizedClientManager applicationAuthorizedClientManager\n  ) {\n    return new OAuth2RequestInterceptor(\n      OAuth2AuthorizeRequest\n        .withClientRegistrationId(\"oAuth2ClientCredentialsApplication\")\n        .principal(\n          new AnonymousAuthenticationToken(\n            CLIENT_PRINCIPAL_APPLICATION,\n            CLIENT_PRINCIPAL_APPLICATION,\n            AuthorityUtils.createAuthorityList(\"ROLE_ANONYMOUS\")\n          )\n        )\n        .build(),\n      applicationAuthorizedClientManager\n    );\n  }\n\n  @Bean\n  @ConditionalOnProperty(\n    prefix = \"spring.security.oauth2.client.registration.oAuth2ClientCredentialsApplication\",\n    name = \"enabled\",\n    havingValue = \"true\"\n  )\n  public OAuth2AuthorizedClientManager applicationAuthorizedClientManager(\n    ClientRegistrationRepository clientRegistrationRepository,\n    OAuth2AuthorizedClientService authorizedClientService\n  ) {\n    return new AuthorizedClientServiceOAuth2AuthorizedClientManager(\n      clientRegistrationRepository,\n      authorizedClientService\n    );\n  }\n\n  public static class OAuth2RequestInterceptor implements RequestInterceptor {\n\n    private final OAuth2AuthorizedClientManager oAuth2AuthorizedClientManager;\n    private final OAuth2AuthorizeRequest oAuth2AuthorizeRequest;\n\n    public OAuth2RequestInterceptor(\n      OAuth2AuthorizeRequest oAuth2AuthorizeRequest,\n      OAuth2AuthorizedClientManager oAuth2AuthorizedClientManager\n    ) {\n      this.oAuth2AuthorizeRequest = oAuth2AuthorizeRequest;\n      this.oAuth2AuthorizedClientManager = oAuth2AuthorizedClientManager;\n    }\n\n    @Override\n    public void apply(final RequestTemplate template) {\n      template.header(HttpHeaders.AUTHORIZATION, getBearerToken());\n    }\n\n    public OAuth2AccessToken getAccessToken() {\n      final OAuth2AuthorizedClient authorizedClient = oAuth2AuthorizedClientManager.authorize(oAuth2AuthorizeRequest);\n      if (authorizedClient == null) {\n        throw new OAuth2AuthenticationException(\"Client failed to authenticate\");\n      }\n      return authorizedClient.getAccessToken();\n    }\n\n    public String getBearerToken() {\n      final OAuth2AccessToken accessToken = getAccessToken();\n      return String.format(\n        \"%s %s\",\n        accessToken.getTokenType().getValue(),\n        accessToken.getTokenValue()\n      );\n    }\n  }\n\n}\n</code></pre>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#spring-application-configuration","title":"Spring Application Configuration","text":"","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#adding-the-spring-boot-oauth2-starter","title":"Adding the Spring Boot OAuth2 Starter","text":"<p>Add the following dependency in your <code>build.gradle</code> (or <code>pom.xml</code> if you are using Maven):</p> <pre><code>dependencies {\n  implementation 'org.springframework.boot:spring-boot-starter-oauth2-client'\n}\n</code></pre> <p>This starter (see official documentation) provides OAuth2 client support for Spring Boot applications.</p>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#defining-oauth2-settings-in-applicationyml","title":"Defining OAuth2 Settings in <code>application.yml</code>","text":"<p>Configure your Keycloak settings in <code>application.yml</code> so that Feign clients can automatically request tokens using <code>client_credentials</code>:</p> <pre><code>spring:\n  security:\n    oauth2:\n      client:\n        registration:\n          oAuth2ClientCredentialsApplication:\n            client-id: your-client-id\n            client-secret: your-client-secret\n            authorization-grant-type: client_credentials\n            scope: read\n        provider:\n          keycloak:\n            token-uri: https://my-keycloak-domain/auth/realms/myrealm/protocol/openid-connect/token\n</code></pre> <p>Key points here:</p> <ul> <li><code>oAuth2ClientCredentialsApplication</code> is the registration name for your client credentials setup.</li> <li><code>client-id</code> and <code>client-secret</code> are values provided by your Keycloak realm.</li> <li><code>authorization-grant-type</code> is set to <code>client_credentials</code>.</li> <li><code>provider.keycloak.token-uri</code> matches the <code>tokenUrl</code> in your OpenAPI specification.</li> </ul> <p>Spring Boot will use these settings to fetch the token automatically before calling your Feign clients.</p>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/03/integration-of-feign-clients-and-openapi-generator-enabling-client_credentials/#conclusion","title":"Conclusion","text":"<p>By defining a <code>client_credentials</code> flow in your OpenAPI specification and configuring Spring Boot OAuth 2.0 Client with Keycloak, you can generate Feign clients that seamlessly retrieve an access token before making API requests. This approach helps ensure that your microservices remain secure and that credentials are fetched in a standardized, automated fashion.</p> <p>Feel free to explore more advanced capabilities of the OpenAPI Generator Gradle Plugin for additional customization options.</p>","tags":["openapi","feign","spring-boot"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/","title":"Level Up Your Kotlin and Spring Boot Testing: Quick Tips and Tricks","text":"<p>When writing tests in Kotlin and Spring Boot, a few well-chosen techniques can make your tests more readable, maintainable, and concise. Here are a couple of handy tips that you can apply to your projects today.</p>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#1-use-the-invoke-operator-to-generate-records","title":"1. Use the <code>invoke</code> Operator to Generate Records","text":"<p>When working with libraries like jOOQ (or similar), it\u2019s common to create records in tests and store them in a test database. You can save boilerplate code by encapsulating record creation in an <code>object</code> with an <code>invoke</code> operator. This approach allows you to generate \u201cfake\u201d or test records with default values while still letting you override specific fields as needed.</p>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#example-code","title":"Example Code","text":"<pre><code>import java.time.LocalDateTime\nimport java.util.*\n\nobject TestRecordFactory {\n\n  operator fun invoke(\n    id: UUID = UUID.randomUUID(),\n    name: String = \"SampleName\",\n    description: String = \"SampleDescription\",\n    createdAt: LocalDateTime = LocalDateTime.now(),\n    updatedAt: LocalDateTime = LocalDateTime.now(),\n    // ... more fields if needed\n  ): SomeRecord = SomeRecord().apply {\n    this.id = id\n    this.name = name\n    this.description = description\n    this.createdAt = createdAt\n    this.updatedAt = updatedAt\n    // ... more fields\n  }\n}\n</code></pre> <p>In the snippet above:</p> <ul> <li>We define an <code>object</code> called <code>TestRecordFactory</code>.</li> <li>The <code>operator fun invoke(...)</code> method is where default values for each field are provided.</li> <li>Within the <code>apply</code> block, we set the properties on an instance of <code>SomeRecord</code> (a placeholder for your actual jOOQ   record   type).</li> </ul>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#usage-in-tests","title":"Usage in Tests","text":"<p>Here\u2019s how you might use it in a test:</p> <pre><code>@Test\nfun `should store a new record with default values`() {\n  // Insert a record with all default values\n  val record = TestRecordFactory()\n  dsl.store(record)\n  // ... further assertions or verifications\n}\n\n@Test\nfun `should override some fields when needed`() {\n  // Insert a record with a custom name\n  val customRecord = TestRecordFactory(\n    name = \"MyCustomName\"\n  )\n  dsl.store(customRecord)\n  // ... further assertions or verifications\n}\n</code></pre> <p>Why it\u2019s useful:</p> <ul> <li>Less boilerplate: No need to manually fill out every field for each test.</li> <li>Flexible overrides: You can customize just the fields you need to.</li> <li>Improved readability: Test code clearly shows intent (creating a \u201cfake\u201d record) without clutter.</li> </ul>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#2-generate-multiple-objects-with-kotlins-list-function","title":"2. Generate Multiple Objects with Kotlin\u2019s List Function","text":"<p>If you want to create multiple objects at once (e.g., a list of test records), Kotlin provides a handy inline function:</p> <pre><code>public inline fun &lt;T&gt; List(size: Int, init: (index: Int) -&gt; T): List&lt;T&gt; = MutableList(size, init)\n</code></pre> <p>This allows you to quickly spin up N instances of a class (or record) with default or generated parameters. It\u2019s especially useful in scenarios where your test setup requires a batch of sample data.</p>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#example-code_1","title":"Example Code","text":"<p>Imagine you have a setup method in your test class that requires creating a certain number of \u201cparent\u201d objects, then associating \u201cchild\u201d objects with them. Here\u2019s how you might do it:</p> <pre><code>@BeforeEach\nfun setUp() {\n  // Create 10 \"parent\" records\n  val parentRecords = List(10) {\n    TestRecordFactory()  // Use your own factory or constructor\n  }\n  store(parentRecords)\n\n  // For each parent, create a random number of \"child\" records\n  parentRecords.forEach { parent -&gt;\n    val childRecords = List((1..10).random()) {\n      ChildRecordFactory(parentId = parent.id) // Example factory usage\n    }\n    store(childRecords)\n  }\n\n  println(\"Initialized ${parentRecords.size} parent records with associated children.\")\n}\n</code></pre> <p>Why it\u2019s useful:</p> <ul> <li>Batch creation: Quickly create a fixed (or random) number of objects for test setup.</li> <li>Readable: The code clearly communicates that you\u2019re initializing multiple objects.</li> <li>Flexible: Pair this with your record factory (invoke) to customize fields as needed.</li> </ul>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#3-using-assertks-prop-function-for-property-based-assertions","title":"3. Using <code>assertk</code>'s <code>prop</code> Function for Property-Based Assertions","text":"<p>When writing tests, comparing every field of an object manually can be tedious and error-prone. The assertk library provides a convenient <code>prop</code> function that allows for clean, property-based assertions.</p>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#example-code_2","title":"Example Code","text":"<pre><code>@Test\nfun `using prop method test`() {\n  // ...\n  // then\n  assertThat(result).all {\n    isNotNull()\n    prop(MyEntity::id).isEqualTo(entityUnderTest.id)\n    prop(MyEntity::name).isEqualTo(entityUnderTest.name)\n    prop(MyEntity::description).isEqualTo(entityUnderTest.description)\n    prop(MyEntity::child).isNotNull()\n  }\n}\n</code></pre> <p>Why it\u2019s useful:</p> <ol> <li>Concise and readable: No need to write repetitive assertThat(result.property).isEqualTo(expected.property)    statements.</li> <li>Type-safe and expressive: Property-based assertions make it easier to verify structured data.</li> <li>Supports transformations: You can use .transform { ... } to normalize or adjust values before comparison.</li> </ol>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#4-use-a-uuid-helper-method-for-predictable-structured-test-data","title":"4. Use a UUID helper method for predictable, structured test data.","text":"<p>When you need unique but deterministic UUIDs in your tests, you can use a simple extension function:</p> <pre><code>import java.util.*\n\nfun Int.uuid(): UUID = UUID.fromString(\"00000000-0000-0000-0000-${this.toString().padStart(11, '0')}\")\n</code></pre>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#example-usage","title":"Example Usage","text":"<pre><code>val entity = anEntity(id = 1.uuid())\n</code></pre>","tags":["kotlin","spring-boot","testing"]},{"location":"2025/02/23/level-up-your-kotlin-and-spring-boot-testing-quick-tips-and-tricks/#conclusion","title":"Conclusion","text":"<p>By combining these techniques, you\u2019ll streamline your test setups, reduce boilerplate, and keep your focus on writing meaningful test logic. Happy testing!</p>","tags":["kotlin","spring-boot","testing"]},{"location":"archive/2025/","title":"2025","text":""},{"location":"archive/2024/","title":"2024","text":""},{"location":"category/kotlin/","title":"Kotlin","text":""},{"location":"category/spring-boot/","title":"Spring Boot","text":""},{"location":"category/testing/","title":"Testing","text":""},{"location":"category/openapi/","title":"Openapi","text":""},{"location":"category/feign/","title":"Feign","text":""},{"location":"category/dgs/","title":"DGS","text":""},{"location":"category/plugins/","title":"Plugins","text":""},{"location":"category/jooq/","title":"Jooq","text":""}]}